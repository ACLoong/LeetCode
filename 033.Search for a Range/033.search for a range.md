#035.Search for a Range 

**<font color=red>难度: Easy</font>**

## 题目内容

Given a sorted array of integers, find the starting and ending position of a given target value.
Your algorithm’s runtime complexity must be in the order of O(log n).
If the target is not found in the array, return [-1, -1].
For example, Given [5, 7, 7, 8, 8, 10] and target value 8, return [3, 4].


## 分析

已经排好了序，用二分查找。

## C++实现1
```c++
class Solution {
public:
	vector<int> searchRange(int A[], int n, int target) {
		const int l = distance(A, lower_bound(A, A + n, target));
		const int u = distance(A, prev(upper_bound(A, A + n, target)));
		if (A[l] != target) // not found
			return vector<int> { -1, -1 };
		else
			return vector<int> { l, u };
		}
};

```
## C++实现2

```c++

int lower_bound(vector<int>& arr, int key) {
    int half;
    int len = arr.size();
    int mid;
    int first = 0;
    while (len > 0) {
        half = len >> 1;
        mid = first + half;
        //in the right part
        if (arr[mid] < key) {
            first = mid + 1;
            //因为first=mid+1,所以这里的len需要在减去half的基础之上再减去1
            len = len - half - 1;
        } else {
            //in the left part
            len = half;
        }
    }
    return first;
}
int upper_bound(vector<int>& arr, int key) {
    int mid;
    int first = 0;
    int len = arr.size();
    int half;
    while (len > 0) {
        half = len >> 1;
        mid = half + first;
        if (arr[mid] > key) {//in the left part
            len = half;
        } else {//if arr[mid]<= key ,in the right part
            first = mid + 1;
            len = len - half - 1;
        }
    }
    return first;
}
	
class Solution {
public:
	vector<int> searchRange (vector<int>& arr,int target) {
		int lower = lower_bound(arr, target);
		int upper = upper_bound(arr, target);
		vector<int> res; 
		if (lower != -1)
			res.push_back(lower);
		res.push_back(upper-1);
		return res;
	}

};
```
## 备注
- lower_bound算法要求在已经按照非递减顺序排序的数组中找到第一个大于等于给定值key的那个数，其基本实现原理是二分查找。
- upper_bound函数要求在按照非递减顺序排好序的数组中找到第一个大于给定值key的那个数，其基本实现原理是二分查找。
- 两种实现参考了stl中的实现方式，返回满足条件的值在数组中的下标。如果找不到满足条件的值，将会返回数组的大小，就像迭代器中的end一样，对应有效下标的下一个值。

